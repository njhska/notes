## 概念

![1670157822717](image/算法/1670157822717.png)

### 时间复杂度

常数操作 跟数据量无关的固定时间的操作

事件复杂的指，进行多少次常数操作

用O 表示:

an^2+bn+c 这样的时间复杂度到数据量很大的时候~=n^2 因此an^2+bn+c的的O表示为 O(n^2)

### 空间复杂度

额外的几个变量O(1)

额外的相同规模的数组O(n)

### 异或

不进位相加

满足  a^a=0;a^0=a;

满足交换律和集合律

### master公式

t(n)=a*t(n/b)+o(n^d);

- t(n) 递归的时间复杂度
- n 递归的规模
- n/b 指递归的子过程的规模都是n/b
- a 有几个子过程
- o(n^d) 其他运算的时间复杂度

master公式求解之后的结果

- 当log{b}a>d时，递归时间复杂度为O(n^d)
- 当log{b}a<d时,递归时间复杂度为O(n^(log{b}(a)))
- 当log{b}a=d时,递归时间复杂度为O(n^d*log(n))

### 堆结构

就是用数组实现完全二叉树，把数组从下标为0开始的项依次放入完全二叉树中

- size 从0开始的几个数
- i位置的左子树下标 2i+1,右子树下标2i+2
- i位置的父下标(i-1)/2
- 堆的高度 log(size)

#### 大/小根堆

指任意子树的头节点都是该子树的最大/小值

#### 小根堆 优先队列代码

```javascript
class PriorityQueue{
    constructor(){
        this.queue=[];
    }
    push(value){
        let index=this.queue.length;
        this.queue.push(value);
        while(this.queue[index]<this.queue[(index-1)/2]){
            this.swap(index,(index-1)/2);
            index=(index-1)/2;
        }
    }

    shift(){
        let first=this.queue[0];
        this.swap(0,this.queue.length-1);
        this.queue.length--;
        let index=0;
        let left=index*2+1;
        while(left<this.queue.length){
            let right=index*2+2;
            let smallest=right<this.queue.length&&this.queue[right]<this.queue[left]?right:left;
            if(this.queue[index]<smallest){
                break;
            }
            this.swap(smallest,index);
            index=smallest;
            left=index*2+1;
        }
        return first;
    }
    get isEmpty(){
        return this.queue.length == 0;
    }
    swap(i,j){
        let temp=this.queue[i];
        this.queue[i]=this.queue[j];
        this.queue[j]=temp;
    }
}

let q=new PriorityQueue();
q.push(4);
q.push(5);
q.push(2);
q.push(1);
q.push(7);
q.push(3);
while(!q.isEmpty){
    console.log(q.shift());
}
```

## 题目

### 取!=0的数的最左边为1的数

```javascript
    function f(num){
        if(num==0) return;
        return num&(~num+1);
    }
```

### 一个数组中有且只有一个数出现了奇数次，求这个数

```javascript
    function f(arr){
        let tem=0;
        for(let i of arr){
            tem=tem^i;
        }
        return tem;
    }
```

### 一个数组中有且只有两个数出现了奇数次，求这两个数

```javascript
function f(arr){
    let t=0;
    for(let i of arr){
        t^=i;
    }
    let leftOne=t&(~t+1);
    let t1=0;
    for(let i of arr){
        if(i&leftOne==0){
            t1^=i;
        }
    }
    let t2=t^t1;
    return [t1,t2];
}
```

### 选择排序

```javascript
    function f(arr) {
        for (let i = 0; i < arr.length-1; i++) {
            let minIndex = i;
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if(i!=minIndex){
                swap(arr,i,minIndex);
            }
        }
        return arr;
    }
    function swap(arr, a1, a2) {
        arr[a1]=arr[a1]^arr[a2];
        arr[a2]=arr[a1]^arr[a2];
        arr[a1]=arr[a1]^arr[a2];
    }
```

### 冒泡排序

```javascript
    function f(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            for (let j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
        return arr;
    }
    function swap(arr, a1, a2) {
        arr[a1] = arr[a1] ^ arr[a2];
        arr[a2] = arr[a1] ^ arr[a2];
        arr[a1] = arr[a1] ^ arr[a2];
    }
```

### 插入排序

时间复杂度

- 最差 O(n^2)
- 最好 O(n)
- 但是时间复杂度要取最差结果

```javascript
    function f(arr) {
        for(let i=1;i<arr.length;i++){
            for(let j=i;j>0;j--){
                if(arr[j]<arr[j-1]){
                    swap(arr,j,j-1);
                }else{
                    break;
                }
            }
        }
        return arr;
    }
    function swap(arr, a1, a2) {
        arr[a1] = arr[a1] ^ arr[a2];
        arr[a2] = arr[a1] ^ arr[a2];
        arr[a1] = arr[a1] ^ arr[a2];
    }
```

### 二分查找的时间复杂度是logn 有序数组

```javascript
function f(arr,num){
    let r=arr.length;
    let l=0;
    while(r>=l){
        let mid=l+((r-l)>>1);
        if(arr[mid]>num){
            r=mid;
        }else if(arr[mid]<num){
            l=mid+1;
        }else{
            return mid;
        }
    }
    return undefined;
}
```

### 有序数组查>=某个数的最左位置

或者<=某个数的最右位置

```javascript
    function f(arr,n){
        let left=0;
        let right=arr.length;
        while(right>left){
            let mid=left+(right-left)>>1;
            if(arr[mid]>=num){
                right=mid;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
```

### 求相邻不等的数组的一个小范围最小值

```javascript
function f(arr){
        if(arr==null||arr.length==0){
            return;
        }
        if(arr.length==1){
            return 0;
        }
        let l=0;
        let r=arr.length-1;
        if(arr[l]<arr[l+1]){
            return l;
        }
        if(arr[r]<arr[r-1]){
            return r;
        }
        let mid=0;
        while(r>l){
            mid=l+((r-l)>>1);
            if(arr[mid]<arr[mid+1]&&arr[mid]<arr[mid-1]){
                return mid;
            }else if(arr[mid]>arr[mid-1]){
                r=mid;
            }else if(arr[mid]>arr[mid+1]){
                l=mid+1;
            }
        }
        return mid;
    }

    let n=f([9,4,3,4,1,6,9]);
    console.log(n);
```

### 求数组一定范围内的最大值，用递归

```javascript
function f(arr,l,r){
    if(l==r){
        return arr[l];
    }
    let mid=l+(r-l)>>1;
    let leftMax=f(arr,l,mid);
    let rightMax=f(arr,mid+1,r);
    return Math.max(leftMax,rightMax);
}
```

### 归并排序

时间复杂度

master公式 a=2 b=2 d=1

log{b}(a)==1 因此时间复杂度为n*log(n)

```javascript
function f(arr,l,r){
    if(l==r){
        return [arr[l]];
    }
    let mid=l+((r-l)>>1);
    let leftArr=f(arr,l,mid);
    let rightArr=f(arr,mid+1,r);
    return merge(leftArr,rightArr);
}
function merge(leftArr,rightArr){
    let result=[];
    let i=0;
    let j=0;
    while(i<leftArr.length&&j<rightArr.length){
        if(leftArr[i]<=rightArr[j]){
            result.push(leftArr[i]);
            i++
        }else{
            result.push(rightArr[j]);
            j++;
        }
    }
    while(i<leftArr.length){
        result.push(leftArr[i]);
        i++;
    }
    while(j<rightArr.length){
        result.push(rightArr[j]);
        j++;
    }
    return result;
}
let arr=f([4,2,6,7,45,7,9],0,6);
console.log(arr);
```

### 求小和

指一个数组中每个值左侧比它自身小的所有数的总和

```javascript
let sum=0;
function f(arr,l,r){
    if(l==r){
        return [arr[l]];
    }
    let mid=l+((r-l)>>1);
    let leftArr=f(arr,l,mid);
    let rightArr=f(arr,mid+1,r);
    return merge(leftArr,rightArr);
}
function merge(leftArr,rightArr){
    let result=[];
    let i=0;
    let j=0;
    while(i<leftArr.length&&j<rightArr.length){
        if(leftArr[i]<rightArr[j]){
            result.push(leftArr[i]);
            sum+=leftArr[i]*(rightArr.length-j);
            i++;
  
        }else{
            result.push(rightArr[j]);
            j++;
        }
    }
    while(i<leftArr.length){
        result.push(leftArr[i]);
        i++;
    }
    while(j<rightArr.length){
        result.push(rightArr[j]);
        j++;
    }   
    return result;
}
let arr=f([1,4,3,2,5],0,4);
console.log(arr);
console.log(sum);
```

### 给定一个数组和一个数，把数组变为左边部分都是<=该数，右边都是大于该数的样子

```javascript
function f(arr,num){
    let i=-1;let j=0;
    while(j<arr.length){
        if(arr[j]<=num){
            if(i+1!=j){
                swap(arr,i+1,j);
            }
            i++;
        }
        j++;
    }
    return arr;
}
function swap(arr,i,j){
    arr[i]=arr[i]^arr[j];
    arr[j]=arr[i]^arr[j];
    arr[i]=arr[i]^arr[j];
}
let arr=f([3,5,8,9,2,5,6,4,9],5);
console.log(arr);
```

### 给定一个数组和一个数，把数组变为左边部分都是<该数，中间=该数，右边都是大于该数的样子

```javascript
    function f(arr, num) {
        let leftIndex = -1;
        let rightIndex = arr.length;
        let index = 0;
        while (index != rightIndex) {
            if (arr[index] == num) {
                index++
            } else if (arr[index] > num) {
                if (index != rightIndex - 1) {
                    swap(arr, index, rightIndex - 1);
                }
                rightIndex--;
            } else {
                if (index != leftIndex + 1) {
                    swap(arr, index, leftIndex + 1);
                }
                leftIndex++;
                index++;
            }
        }
        return arr;
    }
    function swap(arr, i, j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }
    let arr = f([6, 5, 4, 8, 9, 12, 4, 3, 2, 17, 5], 5);
    console.log(arr);
```

### 快速排序

```javascript
    let num=0;
    function sort(arr,left,right){
        if(left<right){
            let mid=part(arr,left,right);
            console.log(`num${num++}:left:${left},right:${right},mid${mid}`);
            sort(arr,left,mid-1);
            sort(arr,mid+1,right);
        }
    }
    function part(arr,left,right){
        let start=left-1;
        let last=arr[right];
        let index=left;
        while(index<right){
            if(arr[index]<=last){
                swap(arr,index++,++start);
            }else{
                index++;
            }
        }
        swap(arr,++start,right);
        return start;
    }
    function swap(arr,a1,a2){
        let temp=arr[a1];
        arr[a1]=arr[a2];
        arr[a2]=temp;
    }
    let arr=[5,2,1,4,6,8,7,3,9,5];
    sort(arr,0,arr.length-1);
    console.log(arr);
```

### 大小根堆排序

```javascript
function heapInsert(arr,index){
    while(arr[index]>arr[(index-1)/2]){
        swap(arr,index,(index-1)/2);
        index=(index-1)/2;
    }
}
function heapify(arr,index,size){
    let left=index*2+1;
    while(left<size){
        let right=index*2+2;
        let largest=right<size&&arr[right]>arr[left]?right:left;
        if(arr[index]>=arr[largest]){
            break;
        }
        swap(arr,index,largest);
        index=largest;
        left=index*2+1;
    }
}
function heapSort(arr){
    for(let i=0;i<arr.length;i++){
        heapInsert(arr,i);
    }
    let size=arr.length;
    swap(arr,0,--size);
    while(size>0){
        heapify(arr,0,size);
        swap(arr,0,--size);  
    }
}
function swap(arr,i,j){
    let temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}
```

### 排序一个接近排列好的数组，指数组中的每一项都离排好序不超过k

利用优先队列 控制时间复杂度在O(n*log(k))

```javascript
function f(arr,k){
    let queue=new PriorityQueue();
    for(let i=0;i<k;i++){
        queue.push(arr[i]);
    }
    let j=0;
    for(let i=k;i<arr.length;i++){
        arr[j] = queue.shift();
        queue.push(arr[i]);
        j++;
    }
    while(!queue.isEmpty){
        arr[j]=queue.shift();
        j++;
    }
}
```

### 时间复杂度为O(n)的排序

```javascript
    function f(arr){
        let map=[0,0,0,0,0,0,0,0,0,0];
        for(let i of arr){
            map[i]++;
        }
        let index=0;
        for(let i=0;i<map.length;i++){
            for(let j=0;j<map[i];j++){
                arr[index++]=i;
            }
        }
    }

    let arr=[3,8,4,9,4,0,1,2,5];
    f(arr);
    console.log(arr);
```

### 桶排序

```javascript
function sort(arr){
    //桶排序 也叫基数排序
    let temp=new Array(arr.length);
    let digit=getMaxDigit(arr);
    //统共需要进出桶digit次
    for(let i=0;i<digit;i++){
        let count=new Array(10).fill(0);
        //统计arr每个数digit位出现的频率
        for(let j=0;j<arr.length;j++){
            let c=getDigit(arr[j],i);
            count[c]++;
        }
        //把频率表转化成<=digit位出现的频率
        for(let i=1;i<10;i++){
            count[i]=count[i]+count[i-1];
        }
        //arr中后边的数后入桶，所以从后边循环
        //在出桶的时候应该放到哪个位置
        for(let j=arr.length-1;j>=0;j--){
            let c=getDigit(arr[j],i);
            temp[count[c]-1]=arr[j];
            count[c]--;
        }
        for(let j=0;j<temp.length;j++){
            arr[j]=temp[j];
        }
    }
}
//获取数组中最大值有多少位
function getMaxDigit(arr){
    let max=Number.MIN_VALUE;
    for(let i of arr){
        max=Math.max(i,max);
    }

    let result=0;
    while(max!=0){
        result++;
        max=Math.trunc(max/10);
    }
    return result;
}
//获取num在digit的位上的值
function getDigit(num,digit){
    return (Math.trunc((num/Math.pow(10,digit)))%10);
}

let arr=[98,67,100,1,6,4,99,101,34];
sort(arr);
console.log(arr);
```

## 链表题目

### 链表

```javascript
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
        this.pre = null;
    }
    //返回首尾
    static help(arr) {
        let head = new Node(arr[0]);
        let result = head;
        for (let i = 1; i < arr.length; i++) {
            let node = new Node(arr[i]);
            head.next = node;
            head = node;
        }
        return [result,head];
    }
}
```

### 反转链表

```javascript
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
        this.pre = null;
    }
}

function reverseDoubleLinkList(head) {
    let current = head;
    while (current.next) {
        current.pre=current.next;
        current = current.next;
    }
    current.pre=null;

    current = head;
    let pre = null;
    while (current.pre) {
        current.next = pre;
        pre = current;
        current = current.pre;
    }
    current.next = pre;
    return current;
}

function reverseLinkList(head) {
    let current = head;
    let pre = null;
    while (current != null) {
        let temp = current.next;
        current.next = pre;
        pre = current;
        current = temp;
    }
    return pre;
}
//使用递归反转单链表
function dosth(current, pre) {
    if (current == null) return pre;
    let temp = current.next;
    current.next = pre;
    dosth(temp, current);
}
```

### 有序链表怎么找到中点

利用快慢指针

```javascript
function findMid(head){
    let fast=head;
    let slow=head;
    //slow到中间或者中间前一位
    // while(fast!=null&&fast.next!=null&&fast.next.next!=null){
    //     slow=slow.next;
    //     fast=fast.next.next;
    // }
    //slow到中间或者中间后一位
    while(fast!=null&&fast.next!=null){
        slow=slow.next;
        fast=fast.next.next;
    }
    return slow.value;
}
```

### 如何判断链表是否为回文结构

空间复杂度O(n)写法

```javascript
//使用栈
function dosth(head){
    let arr=[];
    let cur=head;
    while(cur){
        arr.push(cur.value);
        cur=cur.next;
    }
    cur=head;
    let index=arr.length-1;
    while(cur){
        if(cur.value!=arr[index]){
            return false;
        }
        index--;
        cur=cur.next;
    }
    return true;
}
```

空间复杂度O(1)写法

```javascript
function dosth(head){
    let fast=head;
    let slow=head;
    //找到中点
    while(fast?.next?.next){
        slow=slow.next;
        fast=fast.next.next;
    }
    //从中点到最后逆序
    let anotherHead=reverseLinkList(slow);
    let last=anotherHead;
    let first=head;
    let result=true;
    //从首位两侧迭代链表判断两侧值是否相等
    while(first){
        if(first.value!=last.value){
            result=false;
        }
        first=first.next;
        last=last.next;
    }
    reverseLinkList(anotherHead);
    return result;
}

function reverseLinkList(head){
    let cur=head;
    let pre=null;
    while(cur){
        let temp=cur.next;
        cur.next=pre;
        pre=cur;
        cur=temp;
    }
    return pre;
}
```

### 吧链表更新为根据某个值的区间链表，小于这个值放左边，等于放中间，大于放右边

空间复杂度为O(1)

```javascript
function dosth(head,num){
    //创建小于 等于 大于三个链表的头跟尾
    let sh=null,st=null,eh=null,et=null,bh=null,bt=null;
    let current=head;
    //遍历链表
    //分别加到合适的链表中
    while(current){
        if(current.value<num){
            if(!sh){
                sh=current;
                st=current;
            }else{
                st.next=current;
                st=current;
            }
        }else if(current.value>num){
            if(!bh){
                bh=current;
                bt=current;
            }else{
                bt.next=current;
                bt=current;
            }
        }else{
            if(!eh){
                eh=current;
                et=current;
            }else{
                et.next=current;
                et=current;
            }
        }
        current=current.next;
    }
    //三个链表首位相连
    if(st&&eh){
        st.next=eh;
    }
    if(et&&bh){
        et.next=bh;
    }
}

let head=Node.help([3,4,1,2,6,5,7,9]);
dosth(head,6);
while(head){
    console.log(head.value);
    head=head.next;
}


```

### 链表是否自环

空间复杂度O(n)

```javascript
function isSurround(head){
    let set=new Set();
    let current=head;
    while(current){
        //通过遍历 依次放入set 如果向set中再次添加 自环
        if(set.has(current)){
            return current;
        }else{
            set.add(current);
        }
        current=current.next;
    }
}
```

空间复杂度O(1)

```javascript
function isSurround(head) {
    if (head?.next?.next == null) return null;
    let fast = head.next;
    let slow = head.next.next;
    //是否环绕 如果fast能走完都没跟slow遇见说明不是环绕
    while (fast != slow) {
        if (fast?.next?.next == null) return null;
        slow = slow.next;
        fast = fast.next?.next;
    }
    fast = head;
    while (fast != slow) {
        slow = slow.next;
        fast = fast.next;
    }

    return fast;
}
```

### 两个有终点(无环绕)链表是否相交

```javascript
function isCross(h1,h2){
    let cur1=head1;
    let cur2=head2;
    let n=0;
    //两个链表走到终点
    //如果终点不相等 肯定不相交
    while(cur1){
        n++;
        cur1=cur1.next;
    }
    while(cur2){
        n--;
        cur2=cur2.next;
    }
    if(cur1!=cur2){
        return null;
    }
    //如果相交 相交之前长度不一致 计算出长度差值
    //先走完长链表的差值部分
    if(n>0){
        cur1=head1;
        cur2=head2;
    }else{
        cur1=head2;
        cur2=head1;
    }
    n=Math.abs(n);
    while(n!=0){
        cur1=cur1.next;
        n--;
    }
    while(cur1!=cur2){
        cur1=cur1.next;
        cur2=cur2.next;
    }
    return cur1;
}

let [head1,tail1]=Node.help([1,2,3,4,5]);
let [head2,tail2]=Node.help([1,2,3]);
let [head3,tail3]=Node.help([8,9]);
tail1.next=head3;
tail2.next=head3;
let c= isCross(head1,head2);
console.log(c);
```

### 两个环绕链表是否相交

![1670313179211](image/算法/1670313179211.png)

- 找到两个链表各自的环绕点
- 如果相等就是情况2
  - 把环绕节点作为尾部
  - 按求无环绕链表相交的方式求相交点
- 如果不相等
  - 让一个环绕点继续向下，如果回到自己都碰不到另外一个环绕点就是情况1
  - 如果碰到了就是情况3
  - 返回两个环绕点任意一个就是相交点

## 二叉树

```javascript
class Node{
    constructor(value){
        this.value=value;
        this.left=null;
        this.right=null;
    }
    static createTree(arr){
        let l=arr.length;
        let nodeArr=[];
        for(let i=0;i<l;i++){
            nodeArr.push(new Node(arr[i]));
        }
        for(let i=0;i<l;i++){
            let node=nodeArr[i];
            if((2*i+1)<l){
                node.left=nodeArr[2*i+1];
            }
            if((2*i+2)<l){
                node.right=nodeArr[2*i+2];
            }
        }
        return nodeArr[0];
    }
}
```

### 递归遍历

- 先序 处理第一次相遇 头-左-右
- 中序 处理第二次相遇 左-头-右
- 后序 处理第三次相遇 左-右-头

```javascript
function dosth(node){
    if(node==null){
        return;
    }
    //这里是第一次处理node
    dosth(node.left);
    //在这里第二次处理node
    dosth(node.right);
    //在这里第三次处理node
}
```

### 栈遍历

```javascript
function preOrder(node){
    //把头压入栈中
    let stack=[node];
    while(stack.length){
        //当栈不为空时，弹出一项
        //把它的右左依次压入栈中
        let cur=stack.pop();
        console.log(cur.value);
        if(cur.right){
            stack.push(cur.right);
        }
        if(cur.left){
            stack.push(cur.left);
        }
    }
}

//后顺序为修改压栈的顺序为左右 弹出为右左
//把他们都压入备用栈中
function posOrder(node){
    let stack=[node];
    let temp=[];
    while(stack.length){
        let cur=stack.pop();
        temp.push(cur);
        if(cur.left){
            stack.push(cur.left);
        }
        if(cur.right){
            stack.push(cur.right);
        }
    }
    for(let i=temp.length-1;i>=0;i--){
        console.log(temp[i].value);
    }
}

function inOrder(node){
    let stack=[];
    let cur=node;
    while(stack.length||cur){
        if(cur){
            stack.push(cur);
            cur=cur.left;
        }else{
            cur = stack.pop();
            console.log(cur.value);
            cur=cur.right;
        }
    }
}


```
